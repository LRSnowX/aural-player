import XCTest

/*
    Unit tests for ShuffleSequence.
 */
class ShuffleSequenceTests: XCTestCase {
    
    private var sequence: ShuffleSequence = ShuffleSequence()

    override func setUp() {
        
        // Start with a fresh object before each test
        sequence = ShuffleSequence()
    }

    func testResizeAndReshuffle_lessThan10Elements() {
        
        for size in 1..<10 {
            doTestResizeAndReshuffle(size)
        }
        
        for size in 1..<10 {
            
            for startValue in 1..<size {
                doTestResizeAndReshuffle(size, startValue)
            }
        }
    }
    
    func testResizeAndReshuffle_10Elements() {
        
        for size in [10, 100, 1000, 10000] {
            
            doTestResizeAndReshuffle(size)
            
            for startValue in 0..<size {
                doTestResizeAndReshuffle(size, startValue)
            }
        }
    }
    
    func testResizeAndReshuffle_100Elements() {
        
        doTestResizeAndReshuffle(100)
        
        for startValue in 0..<100 {
            doTestResizeAndReshuffle(100, startValue)
        }
    }
    
    func testResizeAndReshuffle_1000Elements() {
        
        doTestResizeAndReshuffle(1000)
        
        for startValue in 0..<1000 {
            doTestResizeAndReshuffle(1000, startValue)
        }
    }
    
    func testResizeAndReshuffle_10000Elements() {
        
        doTestResizeAndReshuffle(10000)
        
        for startValue in 0..<10000 {
            doTestResizeAndReshuffle(10000, startValue)
        }
    }
    
    private func doTestResizeAndReshuffle(_ size: Int, _ desiredStartValue: Int? = nil) {
        
        sequence.resizeAndReshuffle(size: size, startWith: desiredStartValue)
        
        // Match the actual array count with the expected size.
        XCTAssertEqual(sequence.sequence.count, size)
        
        // Ensure that the start value matches the desired value.
        if let startValue = desiredStartValue {
            
            XCTAssertEqual(sequence.sequence.first, startValue)
            
            // If a start value has been selected, calling peekNext() should produce the 2nd value in the sequence, i.e. with index=1.
            if size > 1 {
                XCTAssertEqual(sequence.sequence[1], sequence.peekNext())
            }
            
        } else {
            
            // If no start value is given, calling peekNext() should produce the first value in the sequence.
            XCTAssertEqual(sequence.sequence.first, sequence.peekNext())
        }
    }
    
    func testResizeAndReshuffle_consecutiveSequenceUniqueness() {
        
        doTestResizeAndReshuffle_consecutiveSequenceUniqueness(3, 100, 33)
        doTestResizeAndReshuffle_consecutiveSequenceUniqueness(5, 100, 5)
        doTestResizeAndReshuffle_consecutiveSequenceUniqueness(10, 100, 2)
        doTestResizeAndReshuffle_consecutiveSequenceUniqueness(100, 100, 1)
        doTestResizeAndReshuffle_consecutiveSequenceUniqueness(500, 1000, 1)
        doTestResizeAndReshuffle_consecutiveSequenceUniqueness(1000, 1000, 1)
        doTestResizeAndReshuffle_consecutiveSequenceUniqueness(10000, 1000, 1)
    }
    
    // Any 2 consecutive sequences generated by resizeAndReshuffle() should be unique.
    private func doTestResizeAndReshuffle_consecutiveSequenceUniqueness(_ size: Int, _ repetitionCount: Int, _ maxNumberOfFailures: Int) {
        
        sequence.resizeAndReshuffle(size: size)
        
        var sequenceBeforeReshuffle: [Int] = Array(sequence.sequence)
        var sequenceAfterReshuffle: [Int]
        
        var failures: Int = 0
        
        for _ in 1...repetitionCount {
        
            sequence.resizeAndReshuffle(size: size)
            sequenceAfterReshuffle = Array(sequence.sequence)
            
            // Size of the sequence should have remained the same.
            XCTAssertEqual(sequence.sequence.count, size)
            
            if sequenceBeforeReshuffle.elementsEqual(sequenceAfterReshuffle) {
                failures.increment()
            }
            
            sequenceBeforeReshuffle = sequenceAfterReshuffle
        }
        
        XCTAssertLessThan(failures, maxNumberOfFailures)
    }
    
    func testResizeAndReshuffle_performance() {
        
        doTestResizeAndReshuffle_performance(100, 2)
        doTestResizeAndReshuffle_performance(1000, 5)
        doTestResizeAndReshuffle_performance(5000, 25)
        doTestResizeAndReshuffle_performance(10000, 50)
    }
    
    private func doTestResizeAndReshuffle_performance(_ size: Int, _ maxExecTime_msec: Double) {
        
        var totalExecTime: Double = 0
        let numRepetitions: Int = 5
        
        // Repeat a few times to get an accurate average execution time.
        for _ in 1...numRepetitions {
            
            // This is important. Must start with an empty sequence to force the sequence to actually allocate a new array each time.
            sequence.clear()

            totalExecTime += executionTimeFor {
                sequence.resizeAndReshuffle(size: size, startWith: size / 2)
            }
        }
        
        let avgExecTime: Double = totalExecTime / Double(numRepetitions)
        XCTAssertLessThan(avgExecTime, maxExecTime_msec / 1000.0)
    }
    
    func testReshuffle() {
        
        for size in 1..<10 {
            
            sequence.resizeAndReshuffle(size: size)
            
            for dontStartWith in 0..<size {
                doTestReshuffle(size, dontStartWith)
            }
        }
        
        for size in [10, 100, 1000, 10000] {
            
            sequence.resizeAndReshuffle(size: size)
            
            for dontStartWith in 0..<size {
                doTestReshuffle(size, dontStartWith)
            }
        }
    }
    
    private func doTestReshuffle(_ size: Int, _ dontStartWith: Int) {
        
        sequence.reShuffle(dontStartWith: dontStartWith)
        
        // Size of the sequence should have remained the same.
        XCTAssertEqual(sequence.sequence.count, size)
        
        // The first element should not equal dontStartWith
        if size > 1 {
            XCTAssertNotEqual(sequence.sequence.first, dontStartWith)
        }
        
        // dontStartWith should be contained in the sequence.
        XCTAssertTrue(sequence.sequence.contains(dontStartWith))

        // peekNext() should produce the first value, i.e. sequence should not have started yet.
        XCTAssertEqual(sequence.sequence.first, sequence.peekNext())
    }
    
    func testReshuffle_consecutiveSequenceUniqueness() {
        
        // The larger the size of the sequence, the lesser the expected failure rate should be.
        
        doTestReshuffle_consecutiveSequenceUniqueness(3, 100, 50)
        doTestReshuffle_consecutiveSequenceUniqueness(5, 100, 5)
        doTestReshuffle_consecutiveSequenceUniqueness(10, 100, 2)
        doTestReshuffle_consecutiveSequenceUniqueness(100, 100, 1)
        doTestReshuffle_consecutiveSequenceUniqueness(1000, 1000, 1)
        doTestReshuffle_consecutiveSequenceUniqueness(10000, 1000, 1)
    }
    
    // Any 2 consecutive sequences generated by resizeAndReshuffle() should be unique, with a certain acceptable failure rate.
    private func doTestReshuffle_consecutiveSequenceUniqueness(_ size: Int, _ repetitionCount: Int, _ maxNumberOfFailures: Int) {
        
        sequence.resizeAndReshuffle(size: size)
        
        sequence.reShuffle(dontStartWith: 0)
        
        var sequenceBeforeReshuffle: [Int] = Array(sequence.sequence)
        var sequenceAfterReshuffle: [Int]
        
        var failures: Int = 0
        
        for _ in 1...repetitionCount {
        
            sequence.reShuffle(dontStartWith: 0)
            sequenceAfterReshuffle = Array(sequence.sequence)
            
            // Size of the sequence should have remained the same.
            XCTAssertEqual(sequence.sequence.count, size)
            
            if sequenceBeforeReshuffle.elementsEqual(sequenceAfterReshuffle) {
                failures.increment()
            }
            
            sequenceBeforeReshuffle = sequenceAfterReshuffle
        }

        XCTAssertLessThan(failures, maxNumberOfFailures)
    }
    
    func testReshuffle_performance() {
        
        doTestReshuffle_performance(100, 1)
        doTestReshuffle_performance(1000, 2)
        doTestReshuffle_performance(5000, 10)
        doTestReshuffle_performance(10000, 20)
    }
    
    private func doTestReshuffle_performance(_ size: Int, _ maxExecTime_msec: Double) {
        
        sequence.resizeAndReshuffle(size: size)
        
        var totalExecTime: Double = 0
        let numRepetitions: Int = 5
        
        // Repeat a few times to get an accurate average execution time.
        for _ in 1...numRepetitions {
            
            totalExecTime += executionTimeFor {
                sequence.reShuffle(dontStartWith: 0)
            }
        }
        
        let avgExecTime: Double = totalExecTime / Double(numRepetitions)
        
        XCTAssertLessThan(avgExecTime, maxExecTime_msec / 1000.0)
    }
    
    func testClear() {
        
        for size in [1, 2, 3, 5, 10, 100, 1000, 5000, 10000] {
            doTestClear(size)
        }
    }
    
    private func doTestClear(_ size: Int) {
        
        sequence.resizeAndReshuffle(size: size)
        XCTAssertEqual(sequence.sequence.count, size)
        
        sequence.clear()
        XCTAssertEqual(sequence.sequence.count, 0)
        XCTAssertFalse(sequence.hasNext)
    }
    
    func testPrevious_sequenceNotStarted() {
        
        // Don't start the sequence.
        sequence.resizeAndReshuffle(size: 10)
        XCTAssertNil(sequence.previous())
    }
    
    func testPrevious_sequenceStarted_atFirstElement() {
        
        // Start the sequence.
        sequence.resizeAndReshuffle(size: 10, startWith: 5)
        XCTAssertNil(sequence.previous())
    }
    
    func testPrevious_sequenceStarted_atSecondElement() {
        
        sequence.resizeAndReshuffle(size: 10)
        let seqArray = Array(sequence.sequence)
        
        // Iterate to the 2nd element.
        XCTAssertEqual(sequence.next(repeatMode: .off), seqArray[0])
        XCTAssertEqual(sequence.next(repeatMode: .off), seqArray[1])
        
        // Perform the test.
        let previous = sequence.previous()
        XCTAssertNotNil(previous)
        XCTAssertEqual(previous, seqArray[0])
    }
    
    func testPrevious_sequenceStarted_iterateBackwardsFromTheEnd() {
        
        sequence.resizeAndReshuffle(size: 10)
        let seqArray = Array(sequence.sequence)
        
        // Iterate to the last element.
        for _ in 0..<seqArray.count {
            _ = sequence.next(repeatMode: .off)
        }
        
        // Iterate backwards, invoking previous()
        var cursor: Int = seqArray.count - 1
        while cursor > 0 {
        
            let previous = sequence.previous()
            XCTAssertNotNil(previous)
            XCTAssertEqual(previous, seqArray[cursor - 1])
            
            cursor.decrement()
        }
    }
}
